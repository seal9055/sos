!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/seal/github/sos/src/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
Black	vga_buffer.rs	/^    Black = 0,$/;"	e	enum:Color
Blue	vga_buffer.rs	/^    Blue = 1,$/;"	e	enum:Color
Brown	vga_buffer.rs	/^    Brown = 6,$/;"	e	enum:Color
Buffer	vga_buffer.rs	/^struct Buffer {$/;"	s
Color	vga_buffer.rs	/^pub enum Color {$/;"	g
ColorCode	vga_buffer.rs	/^impl ColorCode {$/;"	c
ColorCode	vga_buffer.rs	/^struct ColorCode(u8);$/;"	s
Cyan	vga_buffer.rs	/^    Cyan = 3,$/;"	e	enum:Color
DarkGray	vga_buffer.rs	/^    DarkGray = 8,$/;"	e	enum:Color
Failed	lib.rs	/^    Failed = 0x11,$/;"	e	enum:QemuExitCode
Green	lib.rs	/^impl fmt::Display for Green {$/;"	c
Green	lib.rs	/^struct Green(&'static str);$/;"	s
Green	vga_buffer.rs	/^    Green = 2,$/;"	e	enum:Color
LightBlue	vga_buffer.rs	/^    LightBlue = 9,$/;"	e	enum:Color
LightCyan	vga_buffer.rs	/^    LightCyan = 11,$/;"	e	enum:Color
LightGray	vga_buffer.rs	/^    LightGray = 7,$/;"	e	enum:Color
LightGreen	vga_buffer.rs	/^    LightGreen = 10,$/;"	e	enum:Color
LightRed	vga_buffer.rs	/^    LightRed = 12,$/;"	e	enum:Color
Magenta	vga_buffer.rs	/^    Magenta = 5,$/;"	e	enum:Color
Pink	vga_buffer.rs	/^    Pink = 13,$/;"	e	enum:Color
QemuExitCode	lib.rs	/^pub enum QemuExitCode {$/;"	g
Red	lib.rs	/^impl fmt::Display for Red {$/;"	c
Red	lib.rs	/^struct Red(&'static str);$/;"	s
Red	vga_buffer.rs	/^    Red = 4,$/;"	e	enum:Color
ScreenChar	vga_buffer.rs	/^struct ScreenChar {$/;"	s
Success	lib.rs	/^    Success = 0x10,$/;"	e	enum:QemuExitCode
T	lib.rs	/^impl<T> Testable for T$/;"	c
Testable	lib.rs	/^pub trait Testable {$/;"	i
White	vga_buffer.rs	/^    White = 15,$/;"	e	enum:Color
Writer	vga_buffer.rs	/^impl Writer {$/;"	c
Writer	vga_buffer.rs	/^impl fmt::Write for Writer {$/;"	c
Writer	vga_buffer.rs	/^pub struct Writer {$/;"	s
Yellow	vga_buffer.rs	/^    Yellow = 14,$/;"	e	enum:Color
_print	serial.rs	/^pub fn _print(args: ::core::fmt::Arguments) {$/;"	f
_print	vga_buffer.rs	/^pub fn _print(args: fmt::Arguments) {$/;"	f
_start	lib.rs	/^pub extern "C" fn _start() -> ! {$/;"	f
_start	main.rs	/^pub extern "C" fn _start() -> ! {$/;"	f
ascii_character	vga_buffer.rs	/^    ascii_character: u8,$/;"	m	struct:ScreenChar
buffer	vga_buffer.rs	/^    buffer: &'static mut Buffer,$/;"	m	struct:Writer
chars	vga_buffer.rs	/^    chars: [[Volatile<ScreenChar>; BUFFER_WIDTH]; BUFFER_HEIGHT],$/;"	m	struct:Buffer
clear_row	vga_buffer.rs	/^    fn clear_row(&mut self, row: usize) {$/;"	P	implementation:Writer
color_code	vga_buffer.rs	/^    color_code: ColorCode,$/;"	m	struct:ScreenChar
color_code	vga_buffer.rs	/^    color_code: ColorCode,$/;"	m	struct:Writer
column_position	vga_buffer.rs	/^    column_position: usize,$/;"	m	struct:Writer
exit_qemu	lib.rs	/^pub fn exit_qemu(exit_code: QemuExitCode) {$/;"	f
failing_test	lib.rs	/^fn failing_test() {$/;"	f
fmt	lib.rs	/^    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { $/;"	P	implementation:Green
fmt	lib.rs	/^    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { $/;"	P	implementation:Red
new	vga_buffer.rs	/^    fn new(foreground: Color, background: Color) -> ColorCode {$/;"	P	implementation:ColorCode
new_line	vga_buffer.rs	/^    fn new_line(&mut self) {$/;"	P	implementation:Writer
panic	lib.rs	/^fn panic(info: &PanicInfo) -> ! {$/;"	f
panic	main.rs	/^fn panic(info: &PanicInfo) -> ! {$/;"	f
passing_test	lib.rs	/^fn passing_test() {$/;"	f
print	vga_buffer.rs	/^macro_rules! print {$/;"	M
println	vga_buffer.rs	/^macro_rules! println {$/;"	M
run	lib.rs	/^    fn run(&self) -> ();$/;"	P	interface:Testable
run	lib.rs	/^    fn run(&self) {$/;"	f
serial	lib.rs	/^pub mod serial;$/;"	n
serial_print	serial.rs	/^macro_rules! serial_print {$/;"	M
serial_println	serial.rs	/^macro_rules! serial_println {$/;"	M
test_panic_handler	lib.rs	/^pub fn test_panic_handler(info: &PanicInfo) -> ! {$/;"	f
test_println_many	vga_buffer.rs	/^    fn test_println_many() {$/;"	f	module:tests
test_println_output	vga_buffer.rs	/^    fn test_println_output() {$/;"	f	module:tests
test_println_simple	vga_buffer.rs	/^    fn test_println_simple() {$/;"	f	module:tests
test_runner	lib.rs	/^pub fn test_runner(tests: &[&dyn Testable]) {$/;"	f
tests	vga_buffer.rs	/^mod tests {$/;"	n
vga_buffer	lib.rs	/^pub mod vga_buffer;$/;"	n
write_byte	vga_buffer.rs	/^    pub fn write_byte(&mut self, byte: u8) {$/;"	P	implementation:Writer
write_str	vga_buffer.rs	/^    fn write_str(&mut self, s: &str) -> fmt::Result {$/;"	P	implementation:Writer
write_string	vga_buffer.rs	/^    pub fn write_string(&mut self, s: &str) {$/;"	P	implementation:Writer
